\documentclass[10pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}

\usepackage{alltt}

\usepackage{booktabs}

\usepackage[scaled=0.8]{beramono}  % our monospace font
\usepackage[T1]{fontenc}  % this is necessary for beramo to work

\usepackage{listings}

\lstdefinelanguage{hol4}{
  %alsoletter={@=>},
  morekeywords={
     Definition, End, Theorem, Proof, QED},
  %  fun, let, val, in, end, if, then, else, case, of},
  %sensitive=true,
  %morecomment=[l]{//},
  morecomment=[s]{(*}{*)},
  commentstyle=\color{gray},
  showstringspaces=false,
  columns=fullflexible,
  mathescape=true,
  numberstyle=\tiny,
  basicstyle=\ttfamily,
  numbersep=5pt,
  stepnumber=2,
  numbers=none,                   % where to put the line-numbers
  morestring=[b]"
}
\lstset{language=hol4, breaklines=true}
\usepackage{listings}

\usepackage{hyperref}
\usepackage{todonotes}
\newcommand{\heiko}[1]{\todo[inline,author=Heiko,bordercolor=red!20,color=orange!20]{#1}}
\newcommand{\ekey}[1]{\texttt{#1}}

\addto\extrasenglish{
  \def\sectionautorefname{Section}
  \def\subsectionautorefname{Section} % intentional
}

\title{A Programmer's Guide to Proving Theorems with HOL4}
\author{Anonymous}
\date{}

\begin{document}
\maketitle{}

\paragraph*{Summary}
Interactive theorem proving is a method to perform trustworthy, rigorous
mathematical proofs checked by computers.
From a programmer's point of view, learning an ITP system is similar to
learning a new programming language.
The main difference an ITP system allows to first implement a function,
and then prove theorems about it.
This guide is written for experienced programmers, that have seen pen-and-paper
proofs before, but never worked with an ITP system.
If you ever wanted to replace that nice, cozy thought of \emph{this function
should work as I intend it to} with the high-assurance of a rigorous
mathematical proof, this guide is for you\footnote{If you are asking yourself the question how this is even possible, the same reasoning applies.}.

\section{Introduction/Setup}
%
As with any programming language, picking up an ITP system first requires
installing the system.
In this guide we use the HOL4~\cite{HOL4web} theorem prover.
The guide also uses a tool called \emph{Lassie}, equipping HOL4 with training
wheels.

To follow this guide, \texttt{polyML}, \texttt{Apache Ant}, and \texttt{ruby}
must be installed.
For \texttt{polyML}, we recommend downloading the latest version from git
(\url{https://github.com/polyml/polyml}).
Both \texttt{Apache Ant}, and \texttt{ruby} can be installed through the system
package manager.
We provide a setup script that makes sure all the dependencies are installed,
and downloads and installs the latest versions of HOL4 and Lassie with this
guide (\url{https://people.mpi-sws.org/~hbecker/setupHOL4.sh}).
Running the setup script temporarily sets the variables \texttt{HOLDIR}, and
\texttt{LASSIEDIR} to the directories where HOL4 and Lassie have been installed.
To use both tools later, these variables must be be configured permanently
before running HOL4.

\subsection{Running HOL4}

We will explain how to interact using HOL4 using the emacs editor.
There also exist plugins for the vim, and Sublime text editors, and the overall
interaction is the same, only the keybindings may change.

To interact with HOL4 within emacs, it suffices to append the following lines to
the emacs configuration file:
\begin{lstlisting}
(load-file "<HOL install dir>/tools/hol-unicode.el")
(load-file "<HOL install dir>/tools/hol-input.el")
(load-file "<HOL install dir>/tools/holscript-mode.el")
(load-file "<HOL install dir>/tools/hol-mode.el")
\end{lstlisting}

After loading the files, respectively restarting emacs, HOL4 files will by
default open in the HOL4 mode.

In general, HOL4 files always end with the suffix \texttt{Script.sml}.
For example, a theory about natural numbers is called
\texttt{naturalNumbersScript.sml}
In HOL4 speak, files ending with \texttt{Script.sml} are called \emph{script files}.

To interact with HOL4 we must first star ta read-eval-print loop (REPL), similar
to interpreter of programming languages like ruby or python.
After opening a script file in emacs, HOL4 is started by presssing
\ekey{M-h H}.
emacs will then interactively prompt for a position of the HOL4 REPL.

\section{Interacting with the HOL4 REPL}

The HOL4 REPL is an extended version of the polyML~\cite{polymlweb} REPL, and
behaves like the REPL's of other interpreted languages.
After starting the HOL4 REPL, code is send with the keybinding \ekey{M-h r}.

For example, type
\begin{lstlisting}
  3 + 5;
\end{lstlisting}

anywhere in the current script file, highlight it with emacs highlighting
command (\ekey{C-space}, then arrow keys for marking) and send it to the REPL
with \ekey{M-h r}.

The REPL should print:
\begin{lstlisting}[frame=single]
> 3+5;
val it = 8: int
\end{lstlisting}

All of the functionality of the polyML REPL, and in general, the Standard ML
basis library (see e.g. \url{https://smlfamily.github.io/Basis/} for a reference)
are available in the HOL4 REPL.
Thus HOL4 supports creating and manipulating lists, strings, options, and
simple I/O.

As a quick point of reference, \autoref{tbl:keybindings} gives a short, executive summary of the most commonly used keybindings.
If you are not familiar with using emacs in general, we recommend the built-in
tutorial \ekey{C-h t}.

\begin{table}
  \centering
\begin{tabular}{@{}cll@{}}
  \toprule
  Keybinding & \multicolumn{1}{c}{Effect} & \multicolumn{1}{c}{Remark}\\
  \midrule
  \ekey{M-h H} & Start a new HOL4 session & \\
  \ekey{M-h r} & Send marked text to REPL & \\
  \ekey{M-h g} & Start a new proof & Must be within a \texttt{Theorem}, \texttt{Proof} block\\
  \ekey{M-h e} & Applies a tactic & Marked SML code must have type `tactic`\\
  \ekey{M-h d} & Stop current interactive proof \\
  \bottomrule
\end{tabular}
  \caption{Most common HOL4-mode keybindings}\label{tbl:keybindings}
\end{table}

\section{A First (Pen and Paper Style) Proof}\label{sec:hol_ex1}
%
The HOL4 features presented so far are exactly those of an interpreted
programming language.
Next, we will define our first function in HOL4, and prove a first theorem about
it.

A common mathematical notation is $\sum_{i=0}^n f (i)$,
summing the numbers from $0$ to $n$, and applying function $f$.
We define a specialized version for $f (x) = x$ in HOL4:

\begin{lstlisting}
Definition sum_def:
  sum n = if (n = 0) then 0 else n + sum (n-1)
End
\end{lstlisting}

The \lstinline{Definition} and \lstinline{End} keyword tell the REPL that we
define a HOL4 function and mark its end.
In the REPL, \lstinline{sum_def} is the name of the definition, under which it
can be accessed.
As a convention, when defining function $f$ in HOL4, its definition should be
named \lstinline{f_def}.

Alternatively, HOL4 also supports defining a function by a system of equations,
moving the \texttt{case} expression of the \lstinline{sum} function to the
outside:
\begin{lstlisting}
Definition sumEq_def:
  sumEq 0 = 0 /\
  sumEq n = n + sum (n-1)
End
\end{lstlisting}

To avoid a name clash we have renamed the function into lstinline{sumEq}.
Choosing one definition over the other has different benefits and downsides.
As a rule of thumb, it is recommended to choose the latter version, giving a
system of equations if the function requires a top-level \texttt{case}
expression.

As a simple, first example, we will prove a closed form for \lstinline{sum n},
known as the gaussian sum:
\[
  \sum_{i=0}^{n} i = \frac{n * (n + 1)}{2}
\]

In HOL4 this theorem is stated as

\begin{lstlisting}
Theorem gaussian_sum:
  ! n. sum n = n * (n + 1) DIV 2
Proof
QED
\end{lstlisting}

Again, \lstinline{Theorem}, \lstinline{Proof}, and \lstinline{QED} are the
keywords marking a theorem statement in the REPL and the indented line is
the statement that we want to prove.
Similar to a definition, the name \lstinline{gaussian_sum} is an identifier
which is used later to refer to the theorem statement proven in other proofs.
This makes theorems first class citizens of the HOL4 REPL, also allowing
functions to manipulate and inspect their statements.

When proving a theorem for the first time in HOL4, the proof is usually done
interactively.
Starting an interactive proof is as simple as marking the indented line
(\lstinline{! n. sum n = n * (n + 1) DIV 2}) and pressing \ekey{M-h g}.
The HOL4 REPL prints

\begin{lstlisting}[mathescape=true, frame=single]
> val it =
   Proof manager status: 1 proof.
   1. Incomplete goalstack:
        Initial goal:
        $\forall$ n. sum n = n * (n + 1) DIV 2
   : proofs
\end{lstlisting}

In HOL4, theorems are proven by applying so-called \emph{tactics} to the current
goal.
These tactics are a group of SML functions, implemented in the HOL4
distribution, and filled in between the \lstinline{Proof} and the \lstinline{QED}
keywords.
In this tutorial, we decouple learning how the theorem prover works from
learning the syntax of the tactics language by performing interactive proofs
with Lassie using natural language.

To load Lassie and the natural language descriptions required for the proof,
run
\begin{lstlisting}
open LassieLib;
val _ = LassieLib.loadJargon "Arithmetic";
\end{lstlisting}
interactively.

The gaussian sum is the standard example for proofs by induction in math classes.
Following this example, we start the proof with
\begin{lstlisting}
nltac `Induction on 'n';`
\end{lstlisting}

Here, \lstinline{nltac} is a Lassie function that parses natural language and
translates it into a HOL4 tactic.
The parameter \lstinline{`Induction on 'n';`} is the natural language
description of the tactic used.
To apply the tactic, the line must be marked and run with \ekey{M-h e}.
After running the code, the HOL4 REPL shows
\begin{lstlisting}
> OK..
2 subgoals:
val it =

    0.  sum n = n * (n + 1) DIV 2
   ------------------------------------
        sum (SUC n) = SUC n * (SUC n + 1) DIV 2

   sum 0 = 0 * (0 + 1) DIV 2

2 subgoals
   : proof
\end{lstlisting}

The line \lstinline{2 subgoals} tells us that we must prove two separate goals
to finish the proof.
As HOL4 keeps track of these subgoals for us, we need not manage them manually
to make sure that the proof remains error-free.
Note that in the induction step, HOL4 automatically adds the inductive
hypothesis as an assumption (labeled with \lstinline{0}) above a dashed line.

First, we prove the base case \lstinline{sum 0 = 0 * (0 + 1) DIV 2}, then we
show the induction step \lstinline{sum (n + 1) = (n + 1) * (n + 2) DIV 2}.
Function \lstinline{SUC} is the HOL4 version of Peano's successor function.
Intuitively \lstinline{SUC n} refers to the natural number after \lstinline{n},
i.e \lstinline{n + 1}.

As for a pen-and-paper proof, the base case of the induction is trivial, and
solved with the simple statement \lstinline{nltac `simplify with [sum_def].`},
leaving us only with the induction step from above.
In contrast to a pen-and-paper proof, we have to explicitly state that we
simplify with the definition of our summation function (\lstinline{sum_def}).
This is part of the enforced rigour required by the theorem prover\footnote{
We will show in \autoref{todo} how one can get rid of this in certain cases.}.

As for a pen-and-paper proof, the first step on the induction step is to
simplify:
\begin{lstlisting}
nltac `simplify with [sum_def, GSYM ADD_DIV_ADD_DIV, GSYM DIV2_def];`
\end{lstlisting}

Here, \lstinline{ADD_DIV_ADD_DIV} and \lstinline{DIV2_def} are theorems from the
HOL4 standard library used to enrich the simplifier with the additional
knowledge.
To find out their statements, mark the theorem names only, and send them to the
REPL with \ekey{M-h r}.
Sending \lstinline{GSYM} to the REPL shows that the function has type
\lstinline{:thm -> thm}, meaning that it takes a theorem as input and returns a
theorem.
Function \lstinline{GSYM} is a polyML function rotating an equality theorem,
replacing equality $a = b$ with equality $b = a$.
Sending \lstinline{GSYM DIV2_def} and \lstinline{DIV2_def} to the REPL, one can
observe its effect easily.

Using \lstinline{GSYM} can be useful from time to time as rewriting in HOL4 is
directed from left-to-right.
If we have a theorem showing $f x = b$, HOL4 will rewrite any occurence of
$f x$ into an occurence of $b$, but it will never replace occurences of $b$
with occurences of $f x$.

After applying the tactic, the REPL will show the subgoal that remains to be proven:
\begin{lstlisting}
> OK..
1 subgoal:
val it =

    0.  sum n = DIV2 (n * (n + 1))
   ------------------------------------
        DIV2 (2 * SUC n + n * (n + 1)) = DIV2 (SUC n * (SUC n + 1))

   : proof
\end{lstlisting}

Here, function \lstinline{DIV2} is just an abbreviation alternative definition
of division by two.

Applying the following tactics step-by-step closes the proof:

\begin{lstlisting}
nltac `it suffices to show that the arguments are equal;`
nltac `show 'SUC n * (SUC n + 1) = (SUC n + 1) + n * (SUC n + 1)'
         using (simplify with [MULT_CLAUSES]);`
nltac `simplify;`
nltac `show 'n * (n + 1) = SUC n * n' using (trivial using [MULT_CLAUSES, MULT_SYM]);`
nltac `simplify;`
\end{lstlisting}

\begin{sloppypar}
The natural language tactic \lstinline{`show 'SUC n * (SUC n + 1) = (SUC n + 1) + n * (SUC n + 1)' using (simplify with [MULT_CLAUSES]);`}
shows another feature of HOL4:
We can extend the list of assumptions with the theorem mentioned after
\lstinline{show}.
Before running the tactic, the state of the goal is
\end{sloppypar}
\begin{lstlisting}
> OK..
1 subgoal:
val it =

    0.  sum n = DIV2 (n * (n + 1))
   ------------------------------------
        2 * SUC n + n * (n + 1) = SUC n * (SUC n + 1)

   : proof
\end{lstlisting}

and after running the tactic, the subgoal becomes
\begin{lstlisting}
> OK..
1 subgoal:
val it =

    0.  sum n = DIV2 (n * (n + 1))
    1.  SUC n * (SUC n + 1) = SUC n + 1 + n * (SUC n + 1)
   ------------------------------------
        2 * SUC n + n * (n + 1) = SUC n * (SUC n + 1)

   : proof
\end{lstlisting}

Running all tactics, one after another, the REPL shows that the proof is finished by printiting
\begin{lstlisting}
> OK..

val it =
   Initial goal proved.
   $\vdash$ $\forall$ n. sum n = n * (n + 1) DIV 2: proof
\end{lstlisting}

To reuse the theorem later, and to make it automatically checkable by HOL4, we
have to put the natural language into a single call to \lstinline{nltac}.
The full code for the theorme is thus
\begin{lstlisting}[mathescape=true]
Theorem gaussian_sum:
  $\forall$ n. sum n = (n * (n + 1)) DIV 2
Proof
  nltac `
   Induction on 'n'; simplify;
   simplify with [GSYM ADD_DIV_ADD_DIV, GSYM DIV2_def];
   it suffices to show that the arguments are equal;
   show 'SUC n * (SUC n + 1) = (SUC n + 1) + n * (SUC n + 1)' using (simplify with [MULT_CLAUSES]);
   simplify;
   show 'n * (n + 1) = SUC n * n' using (trivial using [MULT_CLAUSES, MULT_SYM]);
   simplify;`
QED
\end{lstlisting}

Marking the complete statement, and running it with \ekey{M-h r} will save the
theorem under the name \lstinline{gaussian_sum}.

\section{Developing Libraries with HOL4}

In the previous section we have looked at a first, self-contained, example of a
HOL4 proof.
To prove the closed form of the gaussian sum, we only needed to define a function
and perform a straight-forward proof by induction.
However, in larger developments it is common to split proofs into smaller
lemmas that are used as part of a central, final theorem\footnote{This is similar to how one would never write larger programs within the \texttt{main} function. It is desirable to split up functionality into programs instead}.

In this section we describe how larger developments are performed with HOL4 by
showing the theorem that there is an infinite number of prime numbers, called
euclid's theorem.

\subsection{Preamble}
Before starting a development in HOL4, it is recommended to declare dependencies
and load theorems that come with the HOL4 theorem prover.
We do so by running

\begin{lstlisting}
open BasicProvers Defn HolKernel Parse Conv SatisfySimps Tactic  boolTheory
  bossLib arithmeticTheory;

open LassieLib arithTacticsLib;

val _ = new_theory "euclid";
\end{lstlisting}

The first \lstinline{open} loads a bunch of theories and tactics from the HOL4
git repository, whereas the second loads Lassie and the natural language
descriptions required for the proofs that we will perform.
The third line, tells HOL4 that we start a new theory, called ``euclid''.
In HOL4 speak, this is the analogous to defining an interface in Java, or a
header file in C.
All definitions and theorems are explicitly part of the interface of a theory.
To prevent errors, the file in which we store the theory has to be called
\lstinline{euclidScript.sml}.
If this correspondance between the file name and theory name is ignored,
HOL4 will fail to build the theory later.
We load the jargon with \lstinline{val _ = LassieLib.loadJargon "Arithmetic";}.

\subsection{Basic Definitions}
Our overall goal is to prove the HOL4 equivalent of the informal statement that
``there is an infinite number of prime numbers''.
The first concept that we need to define is thus what it means for a (natural)
number to be a prime number.

A number $n$ is called a prime numbers if it is only divisible by $1$ and $n$
itself. Thus, we first define a predicate \lstinline{divides} where
\lstinline{a divides b} if and only if \lstinline{b} can be expressed as a
multiple of \lstinline{a}:

\begin{lstlisting}
set_fixity "divides" (Infix(NONASSOC, 450));

Definition divides_def:
  (a divides b) = (? x. b = a * x)
End
\end{lstlisting}
The first line declares \lstinline{divides} as a new infix operator, like $+,-, \ldots$
Next, the \lstinline{Definition}, \lstinline{End} block defines \lstinline{divides} as a
binary infix relation where \lstinline{a divides b} is true, if and only if
there is an \lstinline{x} such that \lstinline{b} is the result of multiplying \lstinline{a} with \lstinline{x}.

Alternatively, we could have defined \lstinline{divides} as a function instead
of an infix operation, as we did in \autoref{sec:hol_ex1}.
Using it as an infix operation however makes it more obvious which number is
divided by which.

Having defined \lstinline{divides} we use it to define a predicate
\lstinline{prime} which is true, if its argument is a prime number.
\begin{lstlisting}
Definition prime_def:
  prime p = (p<>1 /\ !x . x divides p ==> (x=1) \/ (x=p))
End
\end{lstlisting}

The left-hand side of the conjunction (\lstinline{p <> 1}) explicitly excludes
number 1 from being a prime number, and the right-hand side states the HOL4
version of \lstinline{p} being prime if it can only be divided by $1$ and itself.

\subsection{Proving Infrastructural Lemmas}

Before proving euclid's theorem itself, we start by proving some infrastructural
lemmas that will come in handy later.
\begin{lstlisting}
Theorem DIVIDES_0:
  ! x . x divides 0
Proof
  nltac `trivial using [divides_def, MULT_CLAUSES];`
QED

Theorem DIVIDES_ZERO:
  ! x . (0 divides x) = (x = 0)
Proof
  nltac `follows from [divides_def, MULT_CLAUSES];`
QED

Theorem DIVIDES_ONE:
  ! x . (x divides 1) = (x = 1)
Proof
  nltac `follows from [divides_def, MULT_CLAUSES, MULT_EQ_1];`
QED

Theorem DIVIDES_REFL:
  ! x . x divides x
Proof
  nltac `follows from [divides_def, MULT_CLAUSES];`
QED

Theorem DIVIDES_TRANS:
  ! a b c . a divides b /\ b divides c ==> a divides c
Proof
  nltac `follows from [divides_def, MULT_ASSOC];`
QED
\end{lstlisting}

Theorems \lstinline{DIVIDES_0, DIVIDES_ZERO}, and \lstinline{DIVIDES_ONE} show
simple base cases for predicate \lstinline{divides}.
As these follow straight-forwardly from the definition, the Lassie proof is just
\lstinline{nltac `follows from [divides_def, MULT_CLAUSES];`}, resp.
\lstinline{nltac `follows from [divides_def, MULT_CLAUSES, MULT_EQ_-1];`}.

Similarly, one proves theorems about the relation between $+, *$ and $\leq$ and
\lstinline{divides}:
\begin{lstlisting}

Theorem DIVIDES_ADD:
  ! d a b . d divides a /\ d divides b ==> d divides (a + b)
Proof
  nltac `follows from [divides_def, LEFT_ADD_DISTRIB];`
QED

Theorem DIVIDES_SUB:
  !d a b . d divides a /\ d divides b ==> d divides (a - b)
Proof
  nltac `follows from [divides_def, LEFT_SUB_DISTRIB];`
QED

Theorem DIVIDES_ADDL:
  !d a b . d divides a /\ d divides (a + b) ==> d divides b
Proof
  nltac `follows from [ADD_SUB, ADD_SYM, DIVIDES_SUB];`
QED

Theorem DIVIDES_LMUL:
  !d a x . d divides a ==> d divides (x * a)
Proof
  nltac `follows from [divides_def, MULT_ASSOC, MULT_SYM];`
QED

Theorem DIVIDES_RMUL:
  !d a x . d divides a ==> d divides (a * x)
Proof
  nltac `follows from [MULT_SYM,DIVIDES_LMUL];`
QED

Theorem DIVIDES_LE:
  !m n . m divides n ==> m <= n \/ (n = 0)
Proof
  nltac `rewrite [divides_def]; trivial using [];`
QED
\end{lstlisting}

\subsection{Euclid's Theorem}
Having defined prime numbers, and after proving simple properties of
\lstinline{divides}, we next state euclid's theorem and start
exploring its proof.

\begin{lstlisting}
Theorem euclid:
  !n . ?p . n < p /\ prime p
Proof

QED
\end{lstlisting}

After starting the interactive proof with \ekey{M-h g}, we can start exploring
it with Lassie.
The textbook version of the proof is done by contradiction, so we perform the
same step in HOL4: \lstinline{nltac `suppose not;`}.
After running the tactic with \ekey{M-h e} the REPL shows the following goal state:
\begin{lstlisting}[frame=single, mathescape=true]
> OK..
1 subgoal:
val it =

    0.  $\exists$ n. $\forall$ p. n < p $\rightarrow$ $\neg$prime p
   ------------------------------------
        F

   : proof
\end{lstlisting}
The first assumption starts with an existential quantifier, from which we can
obtain the witness. Therefore we next call into the simplifier to automatically
take care of this with \lstinline{nltac `simplify;`} leaving us with
\begin{lstlisting}[frame=single, mathescape=true]
> > > > > # # OK..
1 subgoal:
val it =

    0.  $\forall$ p. n < p $\rightarrow$ $\neg$prime p
   ------------------------------------
        F

   : proof
\end{lstlisting}

The assupmtion now tells us that any natural number $p$ which is greater than
$n$.
On a high-level the goal is to derive a contradiction from this assumption by
finding a prime number that is bigger than $n$.
An integral part of this step is that every natural number greater than $1$ has
a prime factorization\footnote{We have to exclude $1$ here because our definition of prime numbers explicitly ruled out $1$.}.
Before continuing the proof, we prove a theorem that for an arbitrary natural
number $n$ provides us with a prime factor of it.
To this end we first drop the current goal with \ekey{M-h d} and start proving:
\begin{lstlisting}
Theorem PRIME_FACTOR:
  !n . ~(n = 1) ==> ?p . prime p /\ p divides n
Proof
  nltac `
    Complete Induction on 'n';
    rewrite [];
    perform a case split for 'prime n';`
  >- (
    nltac `
      follows from [DIVIDES_REFL];`)
  >- (
    nltac `
      show '?x. x divides n and x <> 1 and x <> n' using (follows from [prime_def]);
      follows from [LESS_OR_EQ, PRIME_2, DIVIDES_LE, DIVIDES_TRANS, DIVIDES_0];`)
QED
\end{lstlisting}

The theorem can be immediately loaded by running \ekey{M-h r} over the complete
text.
However, we recommend stepping through the \lstinline{nltac} steps one-by-one
with \ekey{M-h e} after starting an interactive proof with \ekey{M-h g}.

One particular thing to note here is that this proof uses plain HOL4 tactic
syntax for the first time.
After performing a case split on whether $n$ is prime or not
(\lstinline{perform a case split for 'prime n';}) HOL4 leaves us with two
subgoals to prove:

\begin{lstlisting}[frame=single]
> OK..
2 subgoals:
val it =

    0.  $\forall$ m. m < n $\rightarrow$ m $\neq$ 1 $\rightarrow$ $\exists$ p. prime p $\wedge$ p divides m
    1.  n $\neq$ 1
    2.  $\neg$ prime n
   ------------------------------------
        $\exists$ p. prime p $\wedge$ p divides n

    0.  $\forall$ m. m < n $\rightarrow$ m $\neq$ 1 $\rightarrow$ $\exists$ p. prime p $\wedge$ p divides m
    1.  n $\neq$ 1
    2.  prime n
   ------------------------------------
        $\exists$ p. prime p $\wedge$ p divides n

2 subgoals
   : proof
\end{lstlisting}

The SML level \lstinline{>- ( ... )} then denotes a proof of a subgoal, each
showing only one of the two.

Having shown the theorem \lstinline{PRIME_FACTOR} we can go back to proving
euclids theorem:
\begin{lstlisting}
Theorem euclid:
  !n . ?p . n < p /\ prime p
Proof
  nltac `suppose not; simplify;`
QED
\end{lstlisting}

As a next step, we will obtain a prime factor of $!n + 1$, called $q$.
From this we know that $q$ is prime and \lstinline{q divides FACT n + 1}.
As $q$ is a prime number, we can derive that $q \leq n$.
We obtain a contradiction by deriving that $q = 1$ from the fact that any number
smaller than $n$ is a divisor of $!n$, and theorem \lstinline{DIVIDES_ADDL}.
The full proofscript becomes:
\begin{lstlisting}[mathescape=true]
nltac `
  suppose not; simplify;
  we can derive 'FACT n + 1 <> 1' from [FACT_LESS, neq_zero];
  thus PRIME_FACTOR for 'FACT n + 1';
  we further know '?q. prime q and q divides (FACT n + 1)';
  show 'q <= n' using (suppose not TACCOMB$\$$THEN trivial using [NOT_LESS_EQUAL]);
  show '0 < q' using (follows from [PRIME_POS]);
  show 'q divides FACT n' using (follows from [DIVIDES_FACT]);
  show 'q=1' using (follows from [DIVIDES_ADDL, DIVIDES_ONE]);
  show 'prime 1' using (simplify);
  follows from [NOT_PRIME_1];`
\end{lstlisting}

We recommend stepping through each step one by one and observing the changes to
the proof.

After finishing the proof the theory development is ended by putting
\lstinline{val _ = export_theory();} at the end of the file.
This directive tells HOL4 to export the defined functions and proven theorems
into a file \texttt{gaussTheory.sml} which can be used by future developments.
The file \texttt{gaussTheory.sig} gives an overview of the included theorems and
definitions in a human readable format.

\subsection{Learning HOL4 Tactics}

\heiko{Explain Lassies interactive mode that makes it easy to prettyprint a proofscript with HOL4 tactics}

\subsection{Small Tips and Tricks}

\heiko{Explain extending the simplifier, maybe qpat tactics or some common patterns?}
\heiko{Explain where to get more help -> description manual and help file index}

\section{References}
\printbibliography

\end{document}